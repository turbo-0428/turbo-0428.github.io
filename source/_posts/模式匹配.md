---
title: 模式匹配
date: 2024-09-23 14:50:24
tags:
  - Python
categories:
  - SoftwareDesign
---

前面[笔记](https://turbo-0428.github.io/2024/09/18/%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/)中，我们使用`*.txt`的格式告知查重函数需要对比哪些文件。
这种模式匹配被称为`globbing`，因为早期的Unix中存在一个称为`glob`的工具。Python标准库中同样存在一个`glob`模块，用于实现匹配文件名称。如下：

![](image1.png)

<center>glob匹配示例</center>

<!--more-->

相比于正则表达式，`globbing`模式更加简单，但是效果是相同的。因此，本节我们实现一个简单的`globbing`版本，用来了解模式匹配的工作原理。该匹配器只处理下表中的情况，但是扩展起来也会非常方便。  
<br>

<center>模式匹配示例</center>

|Pattern|Text|Match?|Pattern|Text|Match?|
|:---:|:---:|:---:|:---:|:---:|:---:|
|abc|"abc"|true|a*c|"abc"|true|
|ab|"abc"|false|{a,b}|"a"|true|
|abc|"ab"|false|{a,b}|"c"|false|
|*|""|true|{a,b}|"ab"|false|
|*|"abc"|true|*{x,y}|"abcx"|true|

# 简单模式

匹配在概念上很简单，如果模式的第一个元素与当前位置的目标字符串匹配，那么我们就检查其余模式是否与字符串的剩余内容对应。如果元素与字符串的前端不匹配，或者模式的其余部分与字符串的其余部分不匹配，则匹配失败。（这种模式与正则表达式略有不同，正则表达式支持匹配字符串的部分内容。）

这个设计使用了[责任链(Chain of Responsibility)设计模式]()。即匹配器尝试匹配下一个文本，如果文本不符合匹配规则，则调用链上的下一个匹配器尝试再次匹配。重点是，待匹配的对象并不知道链的长度是多少，它们只需要知道下一个被调用的是哪一个匹配器。

如下图：

![](image2.png)

<center>责任链模式匹配</center>



在某些情况下，我们只需要知道我们正在进行哪种匹配：如，`*`模式可以与任何字符进行匹配。但是，在其他情况下，我们需要一些额外的信息，如，文字`abc`或者可能互换的文本`pdf`、`txt`。因此，我们需要考虑创建匹配对象可以包含这种附加信息的功能，而不是仅仅实现完全匹配。

首先，我们的第一个匹配器需要检查像`abc`这样的文本是否可以匹配。实现如下代码：

```python
class Lit:
    def __init__(self, chars, rest=None):
        self.chars = chars
        self.rest = rest
        
    def match(self, text, start=0):
        end = start + len(self.chars)
        if text[start:end] != self.chars:
            return false
        if self.rest:
            return self.rest.match(text, end)
        return end == len(text)
```

上述代码中，`chars`是要被匹配的字符，`rest`用来匹配文本的剩余部分。如果`rest`是`None`的话，说明该匹配器是责任链上的最后一个匹配器，也就是说该匹配器必须与待匹配的文本的末尾相匹配。

其中`match`方法接收要匹配的文本作为参数，并带有一个可选的`start`参数，指示匹配从什么位置开始。

下面，我们编写一些测试函数：

```python
def test_literal_match_entire_string():
    # /abc/ matches "abc"
    assert Lit("abc").match("abc")

def test_literal_substring_alone_no_match():
    # /ab/ doesn't match "abc"
    assert not Lit("ab").match("abc")

def test_literal_superstring_no_match():
    # /abc/ doesn't match "ab"
    assert not Lit("abc").match("ab")
```

